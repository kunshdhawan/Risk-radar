import os
import sys
import json
import pefile
import zipfile
import tempfile
import hashlib
import lief
import math
import warnings
import joblib
import numpy as np
from collections import Counter
import matplotlib.pyplot as plt
from tabulate import tabulate

# Suppress warnings
warnings.filterwarnings("ignore", category=RuntimeWarning)

class MalwareTester:
    def __init__(self, model_path):
        """Initialize with trained model"""
        try:
            artifacts = joblib.load(model_path)
            self.model = artifacts["model"]
            self.scaler = artifacts["scaler"]
            self.encoder = artifacts["encoder"]
            self.feature_names = artifacts["features"]
            self.min_confidence = artifacts.get("min_confidence", 0.85)
            print("[+] Model loaded successfully")
        except Exception as e:
            print(f"[!] Model loading failed: {str(e)}")
            sys.exit(1)

    def analyze_file(self, file_path):
        """Main analysis function"""
        if not os.path.exists(file_path):
            print(f"[!] File not found: {file_path}")
            return None

        try:
            # Basic file info
            file_info = self._get_file_metadata(file_path)
            file_type = self._detect_file_type(file_path)
            
            # Extract features based on file type
            if file_type == "PE":
                features = self._analyze_pe(file_path)
            elif file_type == "Zip":
                features = self._analyze_zip(file_path)
            else:
                features = self._get_basic_features(file_path)
            
            if features is None:
                return None

            # Prepare feature vector
            feature_vector = np.array([[features.get(f, 0) for f in self.feature_names]])
            scaled_features = self.scaler.transform(feature_vector)

            # Make prediction
            prediction = self._predict_malware(scaled_features)
            
            return {
                "file_info": file_info,
                "analysis": {
                    "file_type": file_type,
                    "features": features,
                    "prediction": prediction
                }
            }

        except Exception as e:
            print(f"[!] Analysis failed: {str(e)}")
            return None

    def _get_file_metadata(self, file_path):
        """Get basic file metadata"""
        return {
            "filename": os.path.basename(file_path),
            "size": os.path.getsize(file_path),
            "sha256": self._calculate_hash(file_path),
            "entropy": self._calculate_entropy(file_path),
            "first_bytes": self._get_first_bytes(file_path)
        }

    def _detect_file_type(self, file_path):
        """Detect file type using magic bytes"""
        try:
            with open(file_path, 'rb') as f:
                magic = f.read(4)
            
            if magic.startswith(b'MZ'):
                return "PE"
            elif magic.startswith(b'PK'):
                return "Zip"
            return "Unknown"
        except:
            return "Unknown"

    def _analyze_pe(self, file_path):
        """Analyze PE files"""
        features = {
            "is_archive": 0,
            **self._get_basic_features(file_path)
        }

        try:
            pe = pefile.PE(file_path)
            lief_binary = lief.parse(file_path)

            # PE-specific features
            pe_features = {
                "sections": len(pe.sections),
                "imports": len(pe.DIRECTORY_ENTRY_IMPORT) if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT') else 0,
                "dll_count": sum(1 for entry in pe.DIRECTORY_ENTRY_IMPORT) if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT') else 0,
                "is_packed": int(self._is_packed(pe)),
                "has_debug": int(hasattr(pe, 'DIRECTORY_ENTRY_DEBUG')),
                "has_tls": int(hasattr(pe, 'DIRECTORY_ENTRY_TLS'))
            }

            # Lief-based features
            if lief_binary:
                pe_features.update({
                    "write_ops": self._count_imports(lief_binary, ['WriteFile', 'fwrite']),
                    "network_ops": self._count_imports(lief_binary, ['socket', 'connect']),
                    "api_calls": len(lief_binary.imported_functions),
                    "has_crypto": int(self._has_crypto(lief_binary))
                })

            features.update(pe_features)
            features.update(self._calculate_derived_features(features))
            
            return features
        except Exception as e:
            print(f"[!] PE analysis error: {str(e)}")
            return features
        finally:
            if 'pe' in locals():
                pe.close()

    def _analyze_zip(self, file_path):
        """Analyze ZIP archives"""
        features = {
            "is_archive": 1,
            **self._get_basic_features(file_path)
        }

        try:
            with zipfile.ZipFile(file_path) as z:
                features.update({
                    "archive_entropy": self._calculate_entropy(file_path),
                    "contained_files": len(z.namelist()),
                    "contains_pe": int(any(f.endswith(('.exe', '.dll')) for f in z.namelist())),
                    "contains_scripts": int(any(f.endswith(('.ps1', '.vbs', '.js')) for f in z.namelist()))
                })

                # Analyze first PE file found in archive
                for f in z.namelist():
                    if f.endswith(('.exe', '.dll')):
                        with z.open(f) as pe_file:
                            with tempfile.NamedTemporaryFile(delete=False) as tmp:
                                tmp.write(pe_file.read())
                                pe_features = self._analyze_pe(tmp.name)
                                if pe_features:
                                    features.update({
                                        "pe_sections": pe_features.get("sections", 0),
                                        "pe_imports": pe_features.get("imports", 0),
                                        "pe_is_packed": pe_features.get("is_packed", 0)
                                    })
                                os.unlink(tmp.name)
                                break

            features.update(self._calculate_derived_features(features))
            return features

        except Exception as e:
            print(f"[!] ZIP analysis error: {str(e)}")
            return features

    def _predict_malware(self, features):
        """Make prediction using the model"""
        try:
            probabilities = self.model.predict_proba(features)[0]
            predicted_idx = np.argmax(probabilities)
            confidence = probabilities[predicted_idx]
            predicted_class = self.encoder.inverse_transform([predicted_idx])[0]
            
            return {
                "class": predicted_class,
                "confidence": float(confidence),
                "is_malicious": confidence >= self.min_confidence and predicted_class != "benign",
                "probabilities": {cls: float(prob) for cls, prob in zip(self.encoder.classes_, probabilities)}
            }
        except Exception as e:
            print(f"[!] Prediction error: {str(e)}")
            return None

    # Helper methods ----------------------------------------------------------
    
    def _get_basic_features(self, file_path):
        """Basic features available for all file types"""
        return {
            "size": os.path.getsize(file_path),
            "entropy": self._calculate_entropy(file_path)
        }

    def _calculate_derived_features(self, features):
        """Calculate ratio-based features"""
        return {
            "entropy_imports_ratio": features.get("entropy", 0) / max(1, features.get("imports", 1)),
            "size_sections_ratio": features.get("size", 0) / max(1, features.get("sections", 1)),
            "api_dll_ratio": features.get("api_calls", 0) / max(1, features.get("dll_count", 1)),
            "write_network_ratio": features.get("write_ops", 0) / max(1, features.get("network_ops", 1)),
            "crypto_ratio": features.get("has_crypto", 0) * features.get("entropy", 0)
        }

    def _calculate_hash(self, file_path):
        """Calculate SHA256 hash"""
        sha256 = hashlib.sha256()
        with open(file_path, "rb") as f:
            while chunk := f.read(8192):
                sha256.update(chunk)
        return sha256.hexdigest()

    def _calculate_entropy(self, file_path, chunk_size=10240):
        """Calculate file entropy"""
        try:
            with open(file_path, "rb") as f:
                data = f.read(chunk_size)
                if not data:
                    return 0.0
                    
                counts = Counter(data)
                entropy = 0.0
                total = len(data)
                for count in counts.values():
                    p = count / total
                    entropy -= p * math.log2(p)
                return entropy
        except:
            return 0.0

    def _get_first_bytes(self, file_path, num_bytes=32):
        """Get first bytes of file in hex"""
        try:
            with open(file_path, "rb") as f:
                return f.read(num_bytes).hex()
        except:
            return ""

    def _is_packed(self, pe):
        """Check if PE file is packed"""
        try:
            # Check section entropy
            for section in pe.sections:
                if section.get_entropy() > 7.0 and b".text" not in section.Name:
                    return True
            
            # Check section names
            suspicious_names = [b'UPX', b'ASPack', b'PECompact']
            for section in pe.sections:
                if any(name in section.Name for name in suspicious_names):
                    return True
            
            return False
        except:
            return False

    def _count_imports(self, binary, import_list):
        """Count specific imports using LIEF"""
        try:
            return sum(1 for func in binary.imported_functions 
                      if func.name in import_list)
        except:
            return 0

    def _has_crypto(self, binary):
        """Check for crypto functions"""
        crypto_terms = ['crypt', 'aes', 'des', 'rc4', 'md5', 'sha1', 'sha256']
        try:
            return any(any(term in func.name.lower() 
                          for term in crypto_terms)
                      for func in binary.imported_functions)
        except:
            return False

    def display_results(self, results):
        """Display analysis results in readable format"""
        if not results:
            print("[!] No results to display")
            return

        file_info = results["file_info"]
        analysis = results["analysis"]
        pred = analysis["prediction"]

        # Basic file info
        print("\n=== File Information ===")
        file_table = [
            ["Filename", file_info["filename"]],
            ["Size", f"{file_info['size']:,} bytes"],
            ["SHA256", file_info["sha256"]],
            ["Entropy", f"{file_info['entropy']:.2f}"],
            ["File Type", analysis["file_type"]]
        ]
        print(tabulate(file_table, tablefmt="grid"))

        # Prediction results
        print("\n=== Malware Analysis ===")
        pred_table = [
            ["Predicted Class", pred["class"]],
            ["Confidence", f"{pred['confidence']:.2%}"],
            ["Verdict", "MALICIOUS" if pred["is_malicious"] else "CLEAN"]
        ]
        print(tabulate(pred_table, tablefmt="grid"))

        # Detailed features
        print("\n=== Key Features ===")
        features = analysis["features"]
        feat_table = [
            ["Packed", bool(features.get("is_packed", 0))],
            ["Sections", features.get("sections", "N/A")],
            ["Imports", features.get("imports", "N/A")],
            ["DLLs", features.get("dll_count", "N/A")],
            ["Network Ops", features.get("network_ops", "N/A")],
            ["Write Ops", features.get("write_ops", "N/A")],
            ["Crypto Indicators", bool(features.get("has_crypto", 0))],
            ["Debug Info", bool(features.get("has_debug", 0))],
            ["TLS Callbacks", bool(features.get("has_tls", 0))]
        ]
        print(tabulate(feat_table, tablefmt="grid"))

        # Archive-specific features
        if features.get("is_archive", 0):
            print("\n=== Archive Contents ===")
            archive_table = [
                ["Files in Archive", features.get("contained_files", "N/A")],
                ["Contains PE", bool(features.get("contains_pe", 0))],
                ["Contains Scripts", bool(features.get("contains_scripts", 0))],
                ["PE Sections", features.get("pe_sections", "N/A")],
                ["PE Imports", features.get("pe_imports", "N/A")],
                ["PE Packed", bool(features.get("pe_is_packed", 0))]
            ]
            print(tabulate(archive_table, tablefmt="grid"))

        # Probability distribution
        print("\n=== Class Probabilities ===")
        prob_table = [[cls, f"{prob:.2%}"] 
                     for cls, prob in pred["probabilities"].items()]
        print(tabulate(prob_table, headers=["Class", "Probability"], tablefmt="grid"))

        # Generate visual report
        self._generate_visual_report(results)

    def _generate_visual_report(self, results):
        """Generate visual elements for the report"""
        pred = results["analysis"]["prediction"]
         
        # Probability distribution chart
        plt.figure(figsize=(10, 5))
        classes = list(pred["probabilities"].keys())
        probabilities = list(pred["probabilities"].values())
        colors = ['red' if cls != "benign" else 'green' for cls in classes]
        
        plt.bar(classes, probabilities, color=colors)
        plt.title("Malware Classification Probabilities")
        plt.ylabel("Probability")
        plt.ylim(0, 1)
        plt.xticks(rotation=45)
        plt.tight_layout()
        
        chart_path = f"{results['file_info']['filename']}_probabilities.png"
        plt.savefig(chart_path)
        plt.close()
        print(f"\n[+] Probability chart saved to {chart_path}")

def main():
    if len(sys.argv) != 3:
        print("Usage: python malware_testing.py <model_path> <file_to_analyze>")
        sys.exit(1)
    
    model_path = sys.argv[1]
    file_path = sys.argv[2]
    
    tester = MalwareTester(model_path)
    results = tester.analyze_file(file_path)
    
    if results:
        tester.display_results(results)
        
        # Save full report
        report_path = f"{os.path.basename(file_path)}_report.json"
        with open(report_path, 'w') as f:
            json.dump(results, f, indent=2)
        print(f"\n[+] Full report saved to {report_path}")

if __name__ == "__main__":
    main()